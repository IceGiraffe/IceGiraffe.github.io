{"posts":[{"title":"Git学习笔记","content":"本文是我的Git学习笔记，主要记录一些常用的命令，掌握这些命令，足够应付绝大多数场景下对Git的需求。 本文主要来自廖雪峰的Git教程和Git官方文档。 Git基础 创建仓库 要创建一个Git仓库，首先进入你想要创建仓库的文件夹，然后使用git init命令初始化。在创建仓库完成后，就可以自在地创建需要的文件，并对文件进行修改。 工作区和暂存区 所谓工作区，就是pwd，你当前看到的文件就是工作区。在工作区和版本库中间，有一个暂存区，想要把新文件或修改后的文件放入仓库，只需要简单的两步，先用add命令将文件加入暂存区，然后使用commit命令将暂存区的文件commit到仓库中去即可。 下面是廖雪峰教程下的一个评论，总结的挺好的 Git管理的文件分为：工作区，版本库，版本库又分为暂存区stage和暂存区分支master(仓库) 工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库 git add把文件从工作区&gt;&gt;&gt;&gt;暂存区，git commit把文件从暂存区&gt;&gt;&gt;&gt;仓库， git diff查看工作区和暂存区差异， git diff --cached查看暂存区和仓库差异， git diff HEAD 查看工作区和仓库的差异， git add的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区， git commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。 git add &lt;file&gt; git commit -m &quot;comment&quot; 版本回退 我个人理解，Git维护了一个树形结构来进行版本控制，HEAD指向哪个节点，哪个节点就是当前版本，使用命令git reset --hard commit_id即可进行版本的切换。 关于commit_id，在Git中，HEAD代表当前版本，HEAD后面每有一个^代表上一个版本，当要回退的版本离HEAD较远时，也可以使用HEAD~&lt;number&gt;，这表示当前版本的前number个版本。 如何获取版本id呢，对于过去的版本，可以使用git log命令，对于“将来”的版本，可以使用git reflog查看命令历史，以确定相应的commit_id。 git reset --hard commit_id 撤销修改 如果暂存区还没有被修改，即还没有执行add命令，想要撤销工作区中的修改，或者向撤销上一次add之后对某个文件的修改，只需要调用git checkout -- &lt;file&gt;即可。这条命令把工作区的文件恢复到与暂存区相同。 如果在add之后，我们想要把恢复到与版本库相同该如何操作呢？这需要两步，第一步，使用 git reset HEAD &lt;file&gt;，这条命令可以把暂存区的修改撤销掉（unstage），重新放回工作区；第二步，git checkout -- &lt;file&gt;. 如果已经commit了，这时候进行撤销修改，实际上就是进行版本回退，参考上一部分。 总结，两条指令： # 将工作区的修改丢弃 git checkout -- &lt;file&gt; # 将暂存区的修改撤销，重新放回工作区，意思就是把暂存区的扔掉，工作区的不变 git reset HEAD &lt;file&gt; 删除文件 也有几种情况，git rm仿佛是git add的反向操作（只是在某些方面）。 如果直接rm，然后我们需要再一次git rm删除暂存区的文件，然后git commit；也可以直接git rm，这会同时删除工作区和暂存区的文件，之后再commit。在commit之前，对于第一种情况，如果想撤销删除，只需要git checkout -- &lt;file&gt;即可，如果是后者，则需要git reset HEAD &lt;file&gt;。如果已经commit了，则需要版本回退。 如果只想从仓库中删除某个文件，而保留本地的文件，加上--cached参数。 Git分支 引子 在引入分支之前，Git的若干个commit都是线性的；而如果我们想在某一个节点出发，进行不同的工作，比如我开发A部分，另一个好朋友开发B部分，最后再将我们的开发成果汇总，这时候就需要用到Git的分支管理。可以想象一棵树，在分开的节点创建了两个分支，那么就相当于该节点指向了两个子树，最后，我们可以通过merge合并进度。 git branch dev git checkout dev # switch to dev* git add &lt;file&gt; git commit &lt;file&gt; # a new commit on the new branch git checkout master git merge dev # then we can delete dev branch git branch -d dev 解决冲突 git merge &lt;name&gt;命令的作用是把name分支和当前分支合并。merge只会影响当前分支，对被merge的分支不会造成任何影响。即从name分支引出一条边指向当前分支，当前分支也会产生一个新的节点。 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log --graph命令可以看到分支合并图。用git log --graph --pretty=oneline --abbrev-commit直观一点点 分支管理策略 注意到，刚刚提到merge之后，会产生一个新的节点，但Git默认情况下在fast-forward模式下工作（如果可能的话），在这种模式下，删除分支后，会丢掉分支信息。为了避免这种情况，可以使用--no-ff参数，表示不使用fast-forward合并分支。这样既保留了分支信息，也能从log中看出来，确实进行过merge操作。 * commit 41528233f01acceb38e1ea142fb5ac90b955598c (HEAD -&gt; master) |\\ Merge: c5a409b 48738dc | | Author: WangFY &lt;137204354@qq.com&gt; | | Date: Fri Aug 28 08:12:48 2020 +0800 | | | | Merge branch 'dev' | | | * commit 48738dc1386ae49546ee4eca497edaa8d9e04d4d (dev) |/ Author: WangFY &lt;137204354@qq.com&gt; | Date: Fri Aug 28 08:12:22 2020 +0800 | | dev | * commit c5a409ba96a37fdac6421471bec871ceb7372400 (origin/master) # 删除dev分支 * commit 41528233f01acceb38e1ea142fb5ac90b955598c (HEAD -&gt; master) |\\ Merge: c5a409b 48738dc | | Author: WangFY &lt;137204354@qq.com&gt; | | Date: Fri Aug 28 08:12:48 2020 +0800 | | | | Merge branch 'dev' | | | * commit 48738dc1386ae49546ee4eca497edaa8d9e04d4d |/ Author: WangFY &lt;137204354@qq.com&gt; | Date: Fri Aug 28 08:12:22 2020 +0800 | | dev | * commit c5a409ba96a37fdac6421471bec871ceb7372400 (origin/master) 在实际开发中，我们应该按照几个基本原则进行分支管理：（摘自廖雪峰教程） 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 stash 有时候，临时接到一个新的任务，可能需要先将当前的工作区和暂存区stash起来。由于不同分支之间，工作区和暂存区是共享的，因此不能随意的git checkout，这把未提交的工作区和暂存区内容直接移到新的分支上了，因此需要stash命令先保存上下文，当我们回到当前任务时，在恢复现场。下面是一个场景： //将保留一个现场 git stash -------------- 完成另外一个任务 -------------- //列出现场 git stash list //恢复现场有两种方法，记得当使用第一种方法时，要手动删除现场 git stash apply &lt;stash@{id}&gt; //恢复现场，如果没有显示地指定stash@{id}则恢复栈顶的那个现场 git stash pop //弹出现场，栈顶现场删除了 //删除现场 git stash drop &lt;stash@{id}&gt; 还有一个指令，git cherry-pick &lt;commit_id&gt;。它可以复制某个commit到当前分支，这条指令会生成一个新的commit。 多人协作 以下内容摘自廖雪峰的教程： 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。处理冲突的过程和本地类似，处理完成之后，再pull即可 Rebase Git标签 我个人理解，Git的标签就是给某一个commit起一个别名，这样可以让我们快速定位到某一个commit，Git的标签是和分支联系在一起的，只能看到当前分支的所有标签。 命令如下： 命令git tag用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m &quot;your message&quot;可以指定标签信息； 命令git tag可以查看所有标签。命令git show &lt;tagname&gt;可以查看标签信息，包括标签的描述和commit的相关信息。 命令git tag -d &lt;name&gt;可以删除标签 远程相关的命令： 命令git push origin &lt;tagname&gt;推送一个标签 命令git push origin --tags推送所有标签 命令git push origin :refs/tags/&lt;tagname&gt;删除远程标签 Git远程 添加远程库 如果要使用github，需要添加SSH key.只需要使用ssh-keygen -t rsa -C &quot;youremail@example.com&quot;命令即可，然后在github上添加id_rsa.pub文件中的公钥即可。 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 从远程库克隆 git clone Git config Git的配置文件包括全局配置和属于每个仓库的局部配置文件，局部配置的优先级最高。Git的全局配置文件是用户主目录下的隐藏文件.gitconfig，仓库的局部配置文件为.git/config。 .gitignore 在.gitignore文件中，我们可以设置让Git忽略我们指定的文件。我们可以手动编写.gitignore，也可以在https://github.com/github/gitignore 中选择合适的文件。 常用命令： $ git add App.class The following paths are ignored by one of your .gitignore files: App.class Use -f if you really want to add them. $ git add -f App.class # 检查gitignore中是哪个规则导致无法正常添加文件 $ git check-ignore -v App.class .gitignore:3:*.class App.class git alias git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot; 附录 实际项目中如何使用Git做分支管理 GitHub Cheat Sheet 中文版 Visual Git Cheat Sheet Another Cheat Sheet Git 官方文档 Learn Git Branching ","link":"https://icegiraffe.github.io/post/git-xue-xi-bi-ji/"}]}